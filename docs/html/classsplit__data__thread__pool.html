<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ssme: split_data_thread_pool&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ssme
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsplit__data__thread__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classsplit__data__thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">split_data_thread_pool&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>split data thread pool Unlike the above thread pool, this pre-allocates work across the nodes. "work" is initiated when there is a new object of type dyn_in_t, which is shared across all threads. Work is performed for every element of the array of static_in_elem_t. The same function is applied to every pair.  
 <a href="classsplit__data__thread__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for split_data_thread_pool&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsplit__data__thread__pool__coll__graph.png" border="0" usemap="#split__data__thread__pool_3_01dyn__in__t_00_01static__in__elem__t_00_01out__t_00_01num__static__elems_00_01debug_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="split__data__thread__pool_3_01dyn__in__t_00_01static__in__elem__t_00_01out__t_00_01num__static__elems_00_01debug_01_4_coll__map" id="split__data__thread__pool_3_01dyn__in__t_00_01static__in__elem__t_00_01out__t_00_01num__static__elems_00_01debug_01_4_coll__map">
<area shape="rect" title="split data thread pool Unlike the above thread pool, this pre&#45;allocates work across the nodes...." alt="" coords="5,95,200,165"/>
<area shape="rect" href="classjoin__threads.html" title="RAII thread killer." alt="" coords="51,5,154,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99b09e92fade3b5283fb7d13d4ae37fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplit__data__thread__pool.html#a99b09e92fade3b5283fb7d13d4ae37fc">split_data_thread_pool</a> (std::array&lt; static_in_elem_t, num_static_elems &gt; &amp;static_container, comp_func_t comp_f, inter_agg_func_t inter_agg_f, intra_agg_func_t intra_agg_f, reset_func_t reset_f, final_func_t final_f=[](const out_t &amp;o){ return o;}, bool mt=true, unsigned num_threads=0)</td></tr>
<tr class="memdesc:a99b09e92fade3b5283fb7d13d4ae37fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ctor spawns the working threads and gets ready to start doing work.  <a href="classsplit__data__thread__pool.html#a99b09e92fade3b5283fb7d13d4ae37fc">More...</a><br /></td></tr>
<tr class="separator:a99b09e92fade3b5283fb7d13d4ae37fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b62820ff71bf54b238060cced05da61"><td class="memItemLeft" align="right" valign="top"><a id="a7b62820ff71bf54b238060cced05da61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplit__data__thread__pool.html#a7b62820ff71bf54b238060cced05da61">~split_data_thread_pool</a> ()</td></tr>
<tr class="memdesc:a7b62820ff71bf54b238060cced05da61"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a7b62820ff71bf54b238060cced05da61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31140d4756c98226680c7fd46b09ccb"><td class="memItemLeft" align="right" valign="top">out_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplit__data__thread__pool.html#ae31140d4756c98226680c7fd46b09ccb">work</a> (dyn_in_t new_input)</td></tr>
<tr class="memdesc:ae31140d4756c98226680c7fd46b09ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the shared data member, then resets some variables, then starts all the work and returns the "average".  <a href="classsplit__data__thread__pool.html#ae31140d4756c98226680c7fd46b09ccb">More...</a><br /></td></tr>
<tr class="separator:ae31140d4756c98226680c7fd46b09ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a77784e8ffb043406e746e9424483ab00"><td class="memItemLeft" align="right" valign="top"><a id="a77784e8ffb043406e746e9424483ab00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>comp_func_t</b> = std::function&lt; out_t(const dyn_in_t &amp;, static_in_elem_t &amp;)&gt;</td></tr>
<tr class="separator:a77784e8ffb043406e746e9424483ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0bbaa49186623703811cc2d7e27f45"><td class="memItemLeft" align="right" valign="top"><a id="afa0bbaa49186623703811cc2d7e27f45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inter_agg_func_t</b> = std::function&lt; out_t(const out_t &amp;, const out_t &amp;, unsigned num_threads, unsigned num_terms_in_thread)&gt;</td></tr>
<tr class="separator:afa0bbaa49186623703811cc2d7e27f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c4cc6d5d6933e94ca4ee67c449b7c0"><td class="memItemLeft" align="right" valign="top"><a id="a40c4cc6d5d6933e94ca4ee67c449b7c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>intra_agg_func_t</b> = std::function&lt; out_t(const out_t &amp;, const out_t &amp;, unsigned num_terms_in_thread)&gt;</td></tr>
<tr class="separator:a40c4cc6d5d6933e94ca4ee67c449b7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010bf37c11f95d3dd0dd6d9b5bb603e"><td class="memItemLeft" align="right" valign="top"><a id="a5010bf37c11f95d3dd0dd6d9b5bb603e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reset_func_t</b> = std::function&lt; out_t(void)&gt;</td></tr>
<tr class="separator:a5010bf37c11f95d3dd0dd6d9b5bb603e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcce3946a048052a2156afa191306d8"><td class="memItemLeft" align="right" valign="top"><a id="acfcce3946a048052a2156afa191306d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>final_func_t</b> = std::function&lt; out_t(const out_t &amp;)&gt;</td></tr>
<tr class="separator:acfcce3946a048052a2156afa191306d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a35345920c09adae9d7df03605ee7b115"><td class="memItemLeft" align="right" valign="top"><a id="a35345920c09adae9d7df03605ee7b115"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplit__data__thread__pool.html#a35345920c09adae9d7df03605ee7b115">worker_thread</a> ()</td></tr>
<tr class="memdesc:a35345920c09adae9d7df03605ee7b115"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs on all threads, and continuously waits for work to do. When a new input comes, calculations begin to be performed, and all their outputs are averaged together. When all the threads have finished their work, the final thread performs finalization. <br /></td></tr>
<tr class="separator:a35345920c09adae9d7df03605ee7b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8ce6efcb43981979dc8c728ae474d7d6"><td class="memItemLeft" align="right" valign="top"><a id="a8ce6efcb43981979dc8c728ae474d7d6"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_output_mut</b></td></tr>
<tr class="separator:a8ce6efcb43981979dc8c728ae474d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89deb86aedcd9df3e3633e1c7d86ce8"><td class="memItemLeft" align="right" valign="top"><a id="aa89deb86aedcd9df3e3633e1c7d86ce8"></a>
std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_input_mut</b></td></tr>
<tr class="separator:aa89deb86aedcd9df3e3633e1c7d86ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac830d3756351ab215601bbcbfae01a42"><td class="memItemLeft" align="right" valign="top"><a id="ac830d3756351ab215601bbcbfae01a42"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_threads</b></td></tr>
<tr class="separator:ac830d3756351ab215601bbcbfae01a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653c412a328e8a763a7de7f1fcf29b83"><td class="memItemLeft" align="right" valign="top"><a id="a653c412a328e8a763a7de7f1fcf29b83"></a>
std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_done</b></td></tr>
<tr class="separator:a653c412a328e8a763a7de7f1fcf29b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0659785556d47ef822172302d19f7b3f"><td class="memItemLeft" align="right" valign="top"><a id="a0659785556d47ef822172302d19f7b3f"></a>
std::map&lt; std::thread::id, std::atomic_bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_has_new_dyn_input</b></td></tr>
<tr class="separator:a0659785556d47ef822172302d19f7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6428a0c86617b522b0389c0c92953cbd"><td class="memItemLeft" align="right" valign="top"><a id="a6428a0c86617b522b0389c0c92953cbd"></a>
out_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_working_agg</b></td></tr>
<tr class="separator:a6428a0c86617b522b0389c0c92953cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d67204df27b838a38cb0dddd2e6877"><td class="memItemLeft" align="right" valign="top"><a id="a83d67204df27b838a38cb0dddd2e6877"></a>
std::promise&lt; out_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_out</b></td></tr>
<tr class="separator:a83d67204df27b838a38cb0dddd2e6877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346dbee5226f28cd11672293b38e3f1e"><td class="memItemLeft" align="right" valign="top"><a id="a346dbee5226f28cd11672293b38e3f1e"></a>
comp_func_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_comp_f</b></td></tr>
<tr class="separator:a346dbee5226f28cd11672293b38e3f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf602be124f4ae0209a10ff4ed5c645"><td class="memItemLeft" align="right" valign="top"><a id="acaf602be124f4ae0209a10ff4ed5c645"></a>
inter_agg_func_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_inter_agg_f</b></td></tr>
<tr class="separator:acaf602be124f4ae0209a10ff4ed5c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc3a1a8eb7f594b500a02b49157b23"><td class="memItemLeft" align="right" valign="top"><a id="a01dc3a1a8eb7f594b500a02b49157b23"></a>
intra_agg_func_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_intra_agg_f</b></td></tr>
<tr class="separator:a01dc3a1a8eb7f594b500a02b49157b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02760036d66c33f525fbd33686869dc1"><td class="memItemLeft" align="right" valign="top"><a id="a02760036d66c33f525fbd33686869dc1"></a>
reset_func_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_reset_f</b></td></tr>
<tr class="separator:a02760036d66c33f525fbd33686869dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1aea1287cb74815e5162e885dc4694"><td class="memItemLeft" align="right" valign="top"><a id="afd1aea1287cb74815e5162e885dc4694"></a>
final_func_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_final_f</b></td></tr>
<tr class="separator:afd1aea1287cb74815e5162e885dc4694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b956e5ac14eacc033acee4bdbdfb4"><td class="memItemLeft" align="right" valign="top"><a id="a291b956e5ac14eacc033acee4bdbdfb4"></a>
dyn_in_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_dynamic_input</b></td></tr>
<tr class="separator:a291b956e5ac14eacc033acee4bdbdfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099612b319538d0f966e92636c7813a8"><td class="memItemLeft" align="right" valign="top"><a id="a099612b319538d0f966e92636c7813a8"></a>
std::array&lt; static_in_elem_t, num_static_elems &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_static_input</b></td></tr>
<tr class="separator:a099612b319538d0f966e92636c7813a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37629e85beb811eb37e5beea9c34fe72"><td class="memItemLeft" align="right" valign="top"><a id="a37629e85beb811eb37e5beea9c34fe72"></a>
std::vector&lt; std::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_threads</b></td></tr>
<tr class="separator:a37629e85beb811eb37e5beea9c34fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4639ace8d39867179169585770e394"><td class="memItemLeft" align="right" valign="top"><a id="acd4639ace8d39867179169585770e394"></a>
<a class="el" href="classjoin__threads.html">join_threads</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_joiner</b></td></tr>
<tr class="separator:acd4639ace8d39867179169585770e394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914d0786f84727a3c23c5fc6264de97e"><td class="memItemLeft" align="right" valign="top"><a id="a914d0786f84727a3c23c5fc6264de97e"></a>
std::map&lt; std::thread::id, std::vector&lt; unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_work_schedule</b></td></tr>
<tr class="separator:a914d0786f84727a3c23c5fc6264de97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4f3cd8f92761fe4cf22912b942c5ce"><td class="memItemLeft" align="right" valign="top"><a id="aec4f3cd8f92761fe4cf22912b942c5ce"></a>
std::atomic_int&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_thread_aves_done</b></td></tr>
<tr class="separator:aec4f3cd8f92761fe4cf22912b942c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename dyn_in_t, typename static_in_elem_t, typename out_t, size_t num_static_elems, bool debug = false&gt;<br />
class split_data_thread_pool&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt;</h3>

<p>split data thread pool Unlike the above thread pool, this pre-allocates work across the nodes. "work" is initiated when there is a new object of type dyn_in_t, which is shared across all threads. Work is performed for every element of the array of static_in_elem_t. The same function is applied to every pair. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dyn_in_t</td><td>the type of input that changes every call to <a class="el" href="classsplit__data__thread__pool.html#ae31140d4756c98226680c7fd46b09ccb" title="changes the shared data member, then resets some variables, then starts all the work and returns the ...">work()</a> (e.g. an Eigen::Matrix of a time series observation) </td></tr>
    <tr><td class="paramname">static_in_elem_t</td><td>(e.g. a particle filter model type) </td></tr>
    <tr><td class="paramname">out_t</td><td>(e.g. a vector of Eigen::MatrixXd) </td></tr>
    <tr><td class="paramname">num_static_elem</td><td>the size of the array </td></tr>
    <tr><td class="paramname">debug</td><td>true if you want debug messages printed </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a99b09e92fade3b5283fb7d13d4ae37fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b09e92fade3b5283fb7d13d4ae37fc">&#9670;&nbsp;</a></span>split_data_thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename dyn_in_t , typename static_in_elem_t , typename out_t , size_t num_static_elems, bool debug = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsplit__data__thread__pool.html">split_data_thread_pool</a>&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt;::<a class="el" href="classsplit__data__thread__pool.html">split_data_thread_pool</a> </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; static_in_elem_t, num_static_elems &gt; &amp;&#160;</td>
          <td class="paramname"><em>static_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comp_func_t&#160;</td>
          <td class="paramname"><em>comp_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inter_agg_func_t&#160;</td>
          <td class="paramname"><em>inter_agg_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intra_agg_func_t&#160;</td>
          <td class="paramname"><em>intra_agg_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reset_func_t&#160;</td>
          <td class="paramname"><em>reset_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">final_func_t&#160;</td>
          <td class="paramname"><em>final_f</em> = <code>[](const&#160;out_t&amp;&#160;o){&#160;return&#160;o;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mt</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ctor spawns the working threads and gets ready to start doing work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_container</td><td>unchanging data used to perform calculations </td></tr>
    <tr><td class="paramname">comp_f</td><td>performs expensive calculation </td></tr>
    <tr><td class="paramname">inter_agg_f</td><td>adds thread's work to overall average </td></tr>
    <tr><td class="paramname">intra_agg_f</td><td>adds to intra-thread average </td></tr>
    <tr><td class="paramname">reset_f</td><td>reset function (usually resets average to 0) </td></tr>
    <tr><td class="paramname">final_f</td><td>finalizer function (default is identity) </td></tr>
    <tr><td class="paramname">mt</td><td>true if you want multithreading </td></tr>
    <tr><td class="paramname">num_threads</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae31140d4756c98226680c7fd46b09ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31140d4756c98226680c7fd46b09ccb">&#9670;&nbsp;</a></span>work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename dyn_in_t , typename static_in_elem_t , typename out_t , size_t num_static_elems, bool debug = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">out_t <a class="el" href="classsplit__data__thread__pool.html">split_data_thread_pool</a>&lt; dyn_in_t, static_in_elem_t, out_t, num_static_elems, debug &gt;::work </td>
          <td>(</td>
          <td class="paramtype">dyn_in_t&#160;</td>
          <td class="paramname"><em>new_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>changes the shared data member, then resets some variables, then starts all the work and returns the "average". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_input</td><td>new parameter input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a floating point average </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ssme/<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classsplit__data__thread__pool.html">split_data_thread_pool</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
