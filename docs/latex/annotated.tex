\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classada__pmmh__mvn}{ada\+\_\+pmmh\+\_\+mvn$<$ numparams, dimobs, numparts, float\+\_\+t $>$}} }{\pageref{classada__pmmh__mvn}}{}
\item\contentsline{section}{\mbox{\hyperlink{classutils_1_1csv__param__sampler}{utils\+::csv\+\_\+param\+\_\+sampler$<$ dimparam, float\+\_\+t $>$}} }{\pageref{classutils_1_1csv__param__sampler}}{}
\item\contentsline{section}{\mbox{\hyperlink{classjoin__threads}{join\+\_\+threads}} \\*R\+A\+II thread killer }{\pageref{classjoin__threads}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1log__trans}{param\+::log\+\_\+trans$<$ float\+\_\+t $>$}} \\*Trans\+\_\+p = log(orig\+\_\+p) }{\pageref{classparam_1_1log__trans}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1logit__trans}{param\+::logit\+\_\+trans$<$ float\+\_\+t $>$}} \\*Trans\+\_\+p = logit(orig\+\_\+p) }{\pageref{classparam_1_1logit__trans}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilter}{L\+W\+Filter$<$ nparts, dimx, dimy, dimparam, float\+\_\+t, debug $>$}} \\*A base class for the Liu-\/\+West Filter }{\pageref{classLWFilter}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilter2}{L\+W\+Filter2$<$ nparts, dimx, dimy, dimparam, float\+\_\+t, debug $>$}} \\*A base class for a modified version of the Liu-\/\+West Filter }{\pageref{classLWFilter2}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilter2FutureSimulator}{L\+W\+Filter2\+Future\+Simulator$<$ nparts, dimx, dimy, dimparam, float\+\_\+t, debug $>$}} \\*An add-\/on for the Liu-\/\+West (version 2) Filter that simulates future observations }{\pageref{classLWFilter2FutureSimulator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilter2WithCovs}{L\+W\+Filter2\+With\+Covs$<$ nparts, dimx, dimy, dimcov, dimparam, float\+\_\+t, debug $>$}} \\*A base class for a modified version of the Liu-\/\+West Filter. Unlike the above class, it allows the state transition to depend on covariates }{\pageref{classLWFilter2WithCovs}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilter2WithCovsFutureSimulator}{L\+W\+Filter2\+With\+Covs\+Future\+Simulator$<$ nparts, dimx, dimy, dimcov, dimparam, float\+\_\+t, debug $>$}} }{\pageref{classLWFilter2WithCovsFutureSimulator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilterFutureSimulator}{L\+W\+Filter\+Future\+Simulator$<$ nparts, dimx, dimy, dimparam, float\+\_\+t, debug $>$}} \\*An add-\/on for the Liu-\/\+West Filter that simulates future observations }{\pageref{classLWFilterFutureSimulator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilterWithCovs}{L\+W\+Filter\+With\+Covs$<$ nparts, dimx, dimy, dimcov, dimparam, float\+\_\+t, debug $>$}} \\*A base class for the Liu-\/\+West Filter. Unlike the above Liu-\/\+Wester filter base class, this allows the state transition to depend on covariates }{\pageref{classLWFilterWithCovs}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLWFilterWithCovsFutureSimulator}{L\+W\+Filter\+With\+Covs\+Future\+Simulator$<$ nparts, dimx, dimy, dimcov, dimparam, float\+\_\+t, debug $>$}} \\*An add-\/on for the Liu-\/\+West Filter that simulates future observations }{\pageref{classLWFilterWithCovsFutureSimulator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmn__resamp__states__and__params}{mn\+\_\+resamp\+\_\+states\+\_\+and\+\_\+params$<$ nparts, dimx, dimparam, float\+\_\+t $>$}} }{\pageref{classmn__resamp__states__and__params}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1null__trans}{param\+::null\+\_\+trans$<$ float\+\_\+t $>$}} \\*Trans\+\_\+p = orig\+\_\+p }{\pageref{classparam_1_1null__trans}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1pack}{param\+::pack$<$ float\+\_\+t, numelem $>$}} \\*Stores transformed parameters, as well as the functions that can change them to the untransformed parameters and back }{\pageref{classparam_1_1pack}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsplit__data__thread__pool}{split\+\_\+data\+\_\+thread\+\_\+pool$<$ dyn\+\_\+in\+\_\+t, static\+\_\+in\+\_\+elem\+\_\+t, out\+\_\+t, num\+\_\+static\+\_\+elems, debug $>$}} \\*Split data thread pool Unlike the above thread pool, this pre-\/allocates work across the nodes. \char`\"{}work\char`\"{} is initiated when there is a new object of type dyn\+\_\+in\+\_\+t, which is shared across all threads. Work is performed for every element of the array of static\+\_\+in\+\_\+elem\+\_\+t. The same function is applied to every pair }{\pageref{classsplit__data__thread__pool}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsvol__bs}{svol\+\_\+bs$<$ nparts, dimx, dimy, resamp\+T, float\+\_\+t $>$}} }{\pageref{classsvol__bs}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSwarm}{Swarm$<$ Mod\+Type, n\+\_\+filt\+\_\+funcs, nstateparts, nparamparts, dimy, dimx, dimparam $>$}} \\*Object that implements a \char`\"{}particle swarm filter\char`\"{} (see \href{https://arxiv.org/abs/2006.15396}{\texttt{ https\+://arxiv.\+org/abs/2006.\+15396}}) This class will draw parameters from samp\+\_\+untrans\+\_\+param (a pure virtual function). This function will usually draw from some distribution that closely approximates an old posterior, and it can even draw from posterior samples in another file }{\pageref{classSwarm}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSwarmWithCovs}{Swarm\+With\+Covs$<$ Mod\+Type, n\+\_\+filt\+\_\+funcs, nstateparts, nparamparts, dimy, dimx, dimcov, dimparam, debug $>$}} }{\pageref{classSwarmWithCovs}}{}
\item\contentsline{section}{\mbox{\hyperlink{classthread__pool}{thread\+\_\+pool$<$ dyn\+\_\+data\+\_\+t, static\+\_\+data\+\_\+t, func\+\_\+output\+\_\+t, debug $>$}} \\*Here we have many concurrent parameter readers, but only a single parameter writer. This thread pool owns one function that returns one (random) floating point number. The pool sits ready to perform calculations on any new parameter value. Once a new parameter value is received, this pool calls its function a fixed number of times, and all of the function output is averaged in a thread-\/safe way. Actually, these function evals are expected to be in the log space, and the log-\/mean-\/exp is calculated using the log-\/sum-\/exp trick. For our particular applications, this function will also depend on observed data that doesn\textquotesingle{}t change once the thread pool has been initialized }{\pageref{classthread__pool}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1transform}{param\+::transform$<$ float\+\_\+t $>$}} \\*Pure virtual base class. cts params only }{\pageref{classparam_1_1transform}}{}
\item\contentsline{section}{\mbox{\hyperlink{classparam_1_1twice__fisher__trans}{param\+::twice\+\_\+fisher\+\_\+trans$<$ float\+\_\+t $>$}} \\*Trans\+\_\+p = log(1+orig\+\_\+p) -\/ log(1-\/orig\+\_\+p) = logit((orig\+\_\+p+1)/2) }{\pageref{classparam_1_1twice__fisher__trans}}{}
\item\contentsline{section}{\mbox{\hyperlink{classuniv__svol__estimator}{univ\+\_\+svol\+\_\+estimator$<$ numparams, dimstate, dimobs, numparts, float\+\_\+t $>$}} }{\pageref{classuniv__svol__estimator}}{}
\end{DoxyCompactList}
